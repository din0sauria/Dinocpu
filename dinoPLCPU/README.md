# DinoPLCPU - 五级流水线RISC-V CPU实现

## 模块关系

### 1. 顶层模块
- **plcomp.v** - 顶层测试模块，实例化PLCPU和存储器
- **PLCPU.v** - 核心CPU模块，集成所有流水线阶段

### 2. 取指阶段(IF)
- **PC.v** - 程序计数器寄存器
- **NPC.v** - 计算下一条指令地址
- **im.v** - 指令存储器

### 3. 译码阶段(ID)
- **ctrl.v** - 主控制器，生成控制信号
- **EXT.v** - 立即数扩展单元  
- **RF.v** - 寄存器文件

### 4. 执行阶段(EX)
- **alu.v** - 算术逻辑单元
- **hazard.v** - 处理数据冒险(前递和阻塞)

### 5. 访存阶段(MEM)
- **dm.v** - 数据存储器

### 6. 写回阶段(WB)
- 通过PLCPU内部的流水线寄存器完成

### 7. 流水线控制
- **pl_reg.v** - 通用流水线寄存器
- **hazard.v** - 冒险检测单元

### 数据流向
1. **取指**：PC → im → IF/ID流水线寄存器
2. **译码**：IF/ID → ctrl + EXT + RF → ID/EX流水线寄存器  
3. **执行**：ID/EX → alu + hazard → EX/MEM流水线寄存器
4. **访存**：EX/MEM → dm → MEM/WB流水线寄存器
5. **写回**：MEM/WB → RF写端口

### 控制信号流
- ctrl模块生成的控制信号通过流水线寄存器逐级传递
- hazard模块根据流水线状态产生stall和forward信号

## 冒险相关
### 半周期读写设计
利用一个周期内的半周期读写（前半周期写、后半周期读）策略，能有效避免读写冲突，从而解决部分结构冒险问题。
- 上升沿读取：在时钟上升沿，dout 从存储器中读取数据。由于写操作还未进行，此时读取的是上一周期写入的数据，不会产生读写冲突。
- 上升沿延迟写操作：在时钟上升沿，将写使能信号 we、写地址 addr 和写数据 din 分别保存到 write_enable、write_addr 和 write_data 中，延迟写操作。
- 下降沿实际写操作：在时钟下降沿，检查 write_enable 信号，若有效则将 write_data 写入 write_addr 对应的存储器位置。

### 数据冒险
五种冒险的分析，简单总结如下：
a. 在一个周期开始，EX 阶段要使用上一条处在 EX 阶段指令的执行结果，此时我们将 EX/MEM 寄存器的数据前递。
b. 在一个周期开始，EX 阶段要使用上一条处在 MEM 阶段指令的执行结果，此时我们将 MEM/WB 寄存器的数据前递。
c. 在一个周期开始，EX 阶段要使用上一条处在 WB 阶段指令的执行结果，此时不需要前递（寄存器堆前递机制）
d. 在第一种情况下，如果是上一条是访存指令，即发生加载—使用型冒险。则需要停顿一个周期。
e. 在发生load-use冒险的时候，如果是load后跟着store指令，并且load指令的rd与store指令的rs1不同而与rs2相同，则不需要停顿，只需要将MEM/WB 寄存器的数据前递到MEM阶段。

1. 数据转发（Forwarding）
数据转发机制会将执行阶段（EX）或访存阶段（MEM）的运算结果直接反馈给需要该数据的指令，避免等待寄存器堆写入。
Forwarding 模块负责生成转发控制信号 ForwardA 和 ForwardB，以此决定 ALU 操作数的来源。
1. 流水线暂停（Stall）
对于 load - use 冒险，数据转发可能无法解决，因为 load 指令在访存阶段才能获取数据，执行阶段没有有效结果。此时需要暂停流水线，等待 load 指令完成数据写入。
PLCPU.v 中 Hazard_Detect 模块负责检测 load - use 冒险并生成暂停信号 stall。
当 stall 信号有效时，IF_ID 和 ID_EX 流水线寄存器暂停更新，使 load 指令有足够时间完成数据读取和写入，之后流水线再继续执行。

#### load - use 冒险解决示例

假设有如下指令序列：

lw x1, 0(x2)  // load 指令，将内存地址 (x2 + 0) 的数据加载到 x1
add x3, x1, x4 // 使用 x1 的值进行加法运算

检测阶段：Hazard_Detect 模块检测到 ID_EX 阶段的 EX_MemRead 有效（表明是 load 指令），且 IF_ID 阶段的 rs1 或 rs2 等于 ID_EX 阶段的 EX_rd（即后续指令要使用 load 指令的目标寄存器），此时生成 stall 信号。
暂停阶段：stall 信号使 IF_ID 和 ID_EX 流水线寄存器暂停更新，add 指令停留在译码阶段，lw 指令继续执行。
完成阶段：lw 指令在访存阶段获取数据，写回阶段将数据写入寄存器堆。之后 stall 信号无效，流水线继续执行，add 指令从寄存器堆读取到正确的 x1 值。

### 控制冒险
控制冒险是指在指令执行过程中，由于控制信号的改变导致后续指令无法正确执行。
控制冒险可能发生在分支指令（如 beq、bne）、跳转指令（如 jal、jalr）等。
fflush 信号用于流水线冲刷，该信号会传递给 pl_reg 模块（流水线寄存器模块）。
当检测到控制冒险（如分支跳转）时，fflush 信号会被置为有效（通常为高电平）。pl_reg 模块在接收到有效 fflush 信号后，会将输出清零，以此清空流水线中已有的无效指令。

PLCPU.v 实例化 NPC 模块并传递 stall 信号，在检测到控制冒险时，通过 stall 信号暂停流水线，等待分支、跳转结果。
NPC.v 根据 NPCOp 信号计算下一条指令地址。当 stall 信号有效时，NPC 保持当前 PC 值，暂停取指；当检测到分支、跳转指令时，计算对应的目标地址，确保后续指令正确取指。
pl_reg.v 实现流水线寄存器功能。当 flush 信号有效时，将寄存器输出清零，冲刷流水线中的无效指令；当 stall_id_ex 或 stall_if_id 信号有效时，暂停流水线更新，避免无效指令进入后续阶段。

## 文件结构
```plaintext
src/
├── alu.v               # ALU运算单元
├── ctrl.v              # 主控制单元
├── ctrl_encode_def.v   # 控制信号定义
├── dm.v                # 数据存储器
├── EXT.v               # 立即数扩展单元
├── hazard.v            # 冒险检测单元
├── im.v                # 指令存储器
├── NPC.v               # 下一条PC计算单元
├── PC.v                # PC寄存器
├── PLCPU.v             # 顶层CPU模块
├── pl_reg.v            # 流水线寄存器
├── plcomp.v            # CPU测试顶层模块
├── plcomp_tb.v         # 测试激励
├── RF.v                # 寄存器文件
```

## 从demo到实现
```plaintext
alu.v # 新增flush信号用于流水线控制，增加指令
ctrl.v # 新增指令支持和指令解码
dm.v # 数据存储器使用了中间变量 write_enable、write_addr 和 write_data 来延迟写操作，在时钟上升沿，当 write_enable 有效时将数据写入存储器，同时更新 write_enable、write_addr 和 write_data 的值。这种设计可以处理在一个周期的前半段写入，后半段读取的情况，避免读写冲突。
EXT.v # 新增了 B 型和 J 型立即数的支持
hazard.v  # 新增模块
NPC.v # 新增支持跳转和分支指令的下一条指令地址计算，能根据不同的指令类型进行灵活的地址计算。
pl_reg.v # 新增支持流水线的刷新和暂停操作，能够更好地处理流水线中的冒险和控制问题。
plcomp.v # 新增流水线冒险支持
```
## 使用方法

### 仿真运行
1. 准备测试程序：
   - 将RISC-V汇编代码编译为机器码
   - 将机器码保存为`riscv_sidascsorting_sim.dat`文件

2. 运行仿真